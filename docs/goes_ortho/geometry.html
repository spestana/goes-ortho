<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>goes_ortho.geometry API documentation</title>
<meta name="description" content="Geometry functions for GOES-R ABI imagery" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>goes_ortho.geometry</code></h1>
</header>
<section id="section-intro">
<p>Geometry functions for GOES-R ABI imagery</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Geometry functions for GOES-R ABI imagery
&#34;&#34;&#34;

import numpy as np

def ABIangle2LonLat(x, y, H, req, rpol, lon_0_deg):
    &#34;&#34;&#34;
    Computes the latitude and longitude (degrees) of a ground point given GOES-R ABI Fixed Grid image coordinates
    
    Parameters
    ------------
    x: float 
        coordinate in the ABI Fixed Grid, scan angle [radians]
    y: float
        coordinate in the ABI Fixed Grid, elevation angle [radians]
    H: float
        satellite distance to Earth center [km]
    req: float
        Earth semi-major axis of GRS80 ellipsoid (equatorial radius) [km]
    rpol: float
        Earth semi-minor axis of GRS80 ellipsoid (polar radius) [km] 
    lon_0_deg: float
        longitude of projection origin (longitude of sub-satellite point) [degrees]
    Returns
    -----------
    lon: float
        longitude of ground point [degrees]
    lat: float
        latitude of ground point [degrees]
    &#34;&#34;&#34;
    
    # intermediate calculations
    a = np.sin(x)**2 + ( np.cos(x)**2 * ( np.cos(y)**2 + ( req**2 / rpol**2 ) * np.sin(y)**2 ) )
    b = -2 * H * np.cos(x) * np.cos(y)
    c = H**2 - req**2

    rs = ( -b - np.sqrt( b**2 - 4*a*c ) ) / ( 2 * a ) # distance from satellite point (S) to P
    
    # solve for rc on the ellipsoid
    #_rc = c*cos(A) ± √[ a2 - c2 sin2 (A) ]
    # add elevation z to rc
    # compute new rs value
    
    Sx = rs * np.cos(x) * np.cos(y)
    Sy = -rs * np.sin(x)
    Sz = rs * np.cos(x) * np.sin(y)
    
    # calculate lat and lon
    lat = np.arctan( ( req**2 / rpol**2 ) * ( Sz / np.sqrt( ( H - Sx )**2 + Sy**2 ) ) )
    lat = np.degrees(lat) #*
    lon = lon_0_deg - np.degrees( np.arctan( Sy / ( H - Sx )) )
    
    # handle when longidue is further west of -180 degrees
    if lon &lt; -180:
        lon = lon + 360
    
    return (lon,lat)

def LonLat2ABIangle(lon_deg, lat_deg, z, H, req, rpol, e, lon_0_deg):
    &#34;&#34;&#34;
    Computes the GOES-R ABI Fixed Grid image coordinates given latitude and longitude (degrees) of a ground point.
    
    Parameters
    ------------
    lon_deg: float
        longitude of ground point [degrees]
    lat_deg: float
        latitude of ground point [degrees]
    z: float
        elevation of ground point above GRS80 ellipsoid [meters]
    H: float
        satellite distance to Earth center [km]
    req: float
        Earth semi-major axis of GRS80 ellipsoid (equatorial radius) [km]
    rpol: float
        Earth semi-minor axis of GRS80 ellipsoid (polar radius) [km]
    e: float
        eccentricity of ellipsoid (e=0.0818191910435 for GRS80) [unitless]
    lon_0_deg: float
        longitude of projection origin (longitude of sub-satellite point) [degrees]
    Returns
    ------------
    x: float
        ABI Fixed Grid x coordinate (scan angle) [radians]
    y: float
        ABI Fixed Grid y coordinate (elevation angle) [radians]
    &#34;&#34;&#34;
    
    # convert lat and lon from degrees to radians
    lon = np.radians(lon_deg)
    lat = np.radians(lat_deg)
    lon_0 = np.radians(lon_0_deg)
      
    # geocentric latitude
    lat_geo = np.arctan( (rpol**2 / req**2) * np.tan(lat) )

    # geocentric distance to point on the ellipsoid
    rc = rpol / np.sqrt(1 - (e**2)*(np.cos(lat_geo)**2)) # this is rc if point is on the ellipsoid
    if ~isinstance(z, int):
        rc = rc + z # this is rc if the point is offset from the ellipsoid by z (meters)

    # intermediate calculations
    Sx = H - rc * np.cos(lat_geo) * np.cos(lon - lon_0)
    Sy = -rc * np.cos(lat_geo) * np.sin(lon - lon_0)
    Sz = rc * np.sin(lat_geo)
    
    # calculate x and y scan angles
    y = np.arctan( Sz / Sx )
    x = np.arcsin( -Sy / np.sqrt( Sx**2 + Sy**2 + Sz**2 ) )
    
    ## determine if this point is visible to the satellite
    #condition = ( H * (H-Sx) ) &lt; ( Sy**2 + (req**2 / rpol**2)*Sz**2 )
    #if condition == True:
    #    print(&#39;Point at {},{} not visible to satellite.&#39;.format(lon_deg,lat_deg))
    #    return (np.nan, np.nan)
    #else:
    #    return (x,y)
    return (x,y)

def calcLookAngles(lon_deg, lat_deg, lon_0_deg):
    &#34;&#34;&#34;
    Calculate azimuth and elevation angles for a geostationary satellite viewed from Earth&#39;s surface.
    
    Parameters
    ------------
    lon_deg: float 
        longitude of ground point [degrees]
    lat_deg: float
        latitude of ground point [degrees]
    lon_0_deg: float
        longitude of projection origin (longitude of sub-satellite point) [degrees]
    Returns
    ------------
    az: float
        azimuth angle [degrees]
    el: float
        elevation angle [degrees]
    &#34;&#34;&#34;
    
    
    # convert lat and lon from degrees to radians
    lon = np.radians(lon_deg)
    lat = np.radians(lat_deg)
    lon_0 = np.radians(lon_0_deg)
    
    s = lon_0 - lon
    
    el = np.arctan( ((np.cos(s)*np.cos(lon)) - 0.1512) / (np.sqrt(1 - ((np.cos(s)**2)*(np.cos(lon)**2)))) )
    
    az = np.arctan( np.tan(s)/np.sin(lon) )
    
    return(np.degrees(az) + 180, np.degrees(el))

def goes_lza(lat_ssp, lon_ssp, lat, lon, H=42164.16, r_eq=6378.137):
    
    &#34;&#34;&#34;
    Compute the Locan Zenith Angle for a point on Earth surface to a GOES-R geostationary satellite.
    See more details from NOAA here: https://www.ncdc.noaa.gov/sites/default/files/attachments/GOES-R_ABI_local_zenith_angle_description.docx
    
    Parameters
    ------------
    lat_ssp: float
       sub-satellite point latitude [degrees]
    lon_ssp: float
       sub-satellite point longitude [degrees]
    lat: float
       view point latitude on Earth&#39;s surfaace [degrees]
    lon: float
       view point longitude on Earth&#39;s surface [degrees]
    elev: float
       view point elevation (heigh above GRS80 ellispoid) [km]
    H: float
       satellite distance to Earth center [km] (defaults to 42164.16 km)
    r_eq: float
        Earth semi-major axis (GRS80 ellipsoid) [km] (defaults to 6378.137 km)
    Returns
    ------------ 
    LZA: float
        local zenith angle [degrees]
    is_point_visible: bool
        True/False flag indicating if the ground point is actually visible to the satellite
    &#34;&#34;&#34;

    # intermediate calculation
    B = np.arccos( np.cos(np.radians(lat)-np.radians(lat_ssp)) * np.cos(np.radians(lon)-np.radians(lon_ssp)) )

    # determine if point is visible to the satellite
    is_point_visible = (B &lt; np.arccos(r_eq / (H+r_eq)))

    # compute LZA
    LZA_radians = np.arcsin( (H * np.sin(B) ) / ( np.sqrt( H**2 + r_eq**2 - 2*H*r_eq*np.cos(B) ) ) )
    
    # convert LZA from radians to degrees
    LZA = LZA_radians * 180/np.pi
    
    return LZA, is_point_visible

def goes_azi(lat_ssp, lon_ssp, lat, lon):
    
    &#34;&#34;&#34;
    Compute azimuth for geostationary satellite, not GOES specific, spherical Earth assumption
    See also: http://tiij.org/issues/issues/3_2/3_2e.html
    
    Parameters
    ------------
    lat_ssp: float
        sub-satellite point latitude [degrees]
    lon_ssp: float
        sub-satellite point longitude [degrees]
    lat: float
        view point latitude on Earth&#39;s surfaace [degrees]
    lon: float
        view point longitude on Earth&#39;s surface [degrees]
    Returns
    ------------
    azi: float
        azimuth angle [degrees]
    &#34;&#34;&#34;
    
    azi = 180 + np.degrees( np.arctan(np.tan(np.radians(lon_ssp - lon))/np.sin(np.radians(lat))) )
    
    return azi.T

def get_nested_coords(ds, x_rad, y_rad):
    
    &#34;&#34;&#34;
    Given the coordinates of a single point in the ABI Fixed Grid coordinates (x_rad and y_rad, in radians) find within a GOES ABI-L1b-Rad dataset, (any of the 2km bands) the coordinates of the nearest &#34;2 km&#34; (56 urad) pixel center, the coordinates of each of the pixel centers of the four &#34;1 km&#34; (28 urad) pixels, and the sixteen &#34;500 m&#34; (14 urad) pixels that are nested within the &#34;2 km&#34; pixel. 
    
    Parameters
    ------------
    ds: xarray.Dataset
        xarray dataset read from a GOES ABI-L1b-Rad NetCDF file of any of the &#34;2 km&#34; bands
    x_rad: float
        x coordinate in the ABI Fixed Grid, scan angle [radians]
    y_rad: float
        y coordinate in the ABI Fixed Grid, elevation angle [radians]
    Returns
    ------------
    nearest_xs_2km: float
        pixel-centered x coordinate of 2km pixel
    nearest_ys_2km: float
        pixel-centered y coordinate of 2km pixel
    nearest_xs_1km: float
        pixel-centered x coordinates of nested 1km pixels
    nearest_ys_1km: float
        pixel-centered y coordinates of nested 1km pixels
    nearest_xs_500m: float
        pixel-centered x coordinates of nested 500 m pixels
    nearest_ys_500m: float
        pixel-centered y coordinates of nested 500 m pixels
    &#34;&#34;&#34;
    
    # &#34;2 km&#34; pixel coordinate
    nearest_xs = ds.sel(x=x_rad, y=y_rad, method=&#34;nearest&#34;).x
    nearest_ys = ds.sel(x=x_rad, y=y_rad, method=&#34;nearest&#34;).y
    nearest_xs_2km, nearest_ys_2km = np.meshgrid(nearest_xs, nearest_ys)
    
    # &#34;1 km&#34; pixel coordinates
    nearest_xs_1km, nearest_ys_1km = np.meshgrid(np.linspace(nearest_xs_2km[0][0]-(28e-6)*0.5, nearest_xs_2km[0][0]+(28e-6)*0.5, num=2), \
                                                 np.linspace(nearest_ys_2km[0][0]-(28e-6)*0.5, nearest_ys_2km[0][0]+(28e-6)*0.5, num=2))

    # &#34;500 m&#34; pixel coordinates
    nearest_xs_500m, nearest_ys_500m = np.meshgrid(np.linspace(nearest_xs_2km[0][0]-(14e-6)*1.5, nearest_xs_2km[0][0]+(14e-6)*1.5, num=4), \
                                                   np.linspace(nearest_ys_2km[0][0]-(14e-6)*1.5, nearest_ys_2km[0][0]+(14e-6)*1.5, num=4))


    return nearest_xs_2km, nearest_ys_2km, nearest_xs_1km, nearest_ys_1km, nearest_xs_500m, nearest_ys_500m</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="goes_ortho.geometry.ABIangle2LonLat"><code class="name flex">
<span>def <span class="ident">ABIangle2LonLat</span></span>(<span>x, y, H, req, rpol, lon_0_deg)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the latitude and longitude (degrees) of a ground point given GOES-R ABI Fixed Grid image coordinates</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float </code></dt>
<dd>coordinate in the ABI Fixed Grid, scan angle [radians]</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>coordinate in the ABI Fixed Grid, elevation angle [radians]</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>satellite distance to Earth center [km]</dd>
<dt><strong><code>req</code></strong> :&ensp;<code>float</code></dt>
<dd>Earth semi-major axis of GRS80 ellipsoid (equatorial radius) [km]</dd>
<dt><strong><code>rpol</code></strong> :&ensp;<code>float</code></dt>
<dd>Earth semi-minor axis of GRS80 ellipsoid (polar radius) [km]</dd>
<dt><strong><code>lon_0_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of projection origin (longitude of sub-satellite point) [degrees]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of ground point [degrees]</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude of ground point [degrees]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ABIangle2LonLat(x, y, H, req, rpol, lon_0_deg):
    &#34;&#34;&#34;
    Computes the latitude and longitude (degrees) of a ground point given GOES-R ABI Fixed Grid image coordinates
    
    Parameters
    ------------
    x: float 
        coordinate in the ABI Fixed Grid, scan angle [radians]
    y: float
        coordinate in the ABI Fixed Grid, elevation angle [radians]
    H: float
        satellite distance to Earth center [km]
    req: float
        Earth semi-major axis of GRS80 ellipsoid (equatorial radius) [km]
    rpol: float
        Earth semi-minor axis of GRS80 ellipsoid (polar radius) [km] 
    lon_0_deg: float
        longitude of projection origin (longitude of sub-satellite point) [degrees]
    Returns
    -----------
    lon: float
        longitude of ground point [degrees]
    lat: float
        latitude of ground point [degrees]
    &#34;&#34;&#34;
    
    # intermediate calculations
    a = np.sin(x)**2 + ( np.cos(x)**2 * ( np.cos(y)**2 + ( req**2 / rpol**2 ) * np.sin(y)**2 ) )
    b = -2 * H * np.cos(x) * np.cos(y)
    c = H**2 - req**2

    rs = ( -b - np.sqrt( b**2 - 4*a*c ) ) / ( 2 * a ) # distance from satellite point (S) to P
    
    # solve for rc on the ellipsoid
    #_rc = c*cos(A) ± √[ a2 - c2 sin2 (A) ]
    # add elevation z to rc
    # compute new rs value
    
    Sx = rs * np.cos(x) * np.cos(y)
    Sy = -rs * np.sin(x)
    Sz = rs * np.cos(x) * np.sin(y)
    
    # calculate lat and lon
    lat = np.arctan( ( req**2 / rpol**2 ) * ( Sz / np.sqrt( ( H - Sx )**2 + Sy**2 ) ) )
    lat = np.degrees(lat) #*
    lon = lon_0_deg - np.degrees( np.arctan( Sy / ( H - Sx )) )
    
    # handle when longidue is further west of -180 degrees
    if lon &lt; -180:
        lon = lon + 360
    
    return (lon,lat)</code></pre>
</details>
</dd>
<dt id="goes_ortho.geometry.LonLat2ABIangle"><code class="name flex">
<span>def <span class="ident">LonLat2ABIangle</span></span>(<span>lon_deg, lat_deg, z, H, req, rpol, e, lon_0_deg)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the GOES-R ABI Fixed Grid image coordinates given latitude and longitude (degrees) of a ground point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lon_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of ground point [degrees]</dd>
<dt><strong><code>lat_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude of ground point [degrees]</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>elevation of ground point above GRS80 ellipsoid [meters]</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>satellite distance to Earth center [km]</dd>
<dt><strong><code>req</code></strong> :&ensp;<code>float</code></dt>
<dd>Earth semi-major axis of GRS80 ellipsoid (equatorial radius) [km]</dd>
<dt><strong><code>rpol</code></strong> :&ensp;<code>float</code></dt>
<dd>Earth semi-minor axis of GRS80 ellipsoid (polar radius) [km]</dd>
<dt><strong><code>e</code></strong> :&ensp;<code>float</code></dt>
<dd>eccentricity of ellipsoid (e=0.0818191910435 for GRS80) [unitless]</dd>
<dt><strong><code>lon_0_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of projection origin (longitude of sub-satellite point) [degrees]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>ABI Fixed Grid x coordinate (scan angle) [radians]</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ABI Fixed Grid y coordinate (elevation angle) [radians]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LonLat2ABIangle(lon_deg, lat_deg, z, H, req, rpol, e, lon_0_deg):
    &#34;&#34;&#34;
    Computes the GOES-R ABI Fixed Grid image coordinates given latitude and longitude (degrees) of a ground point.
    
    Parameters
    ------------
    lon_deg: float
        longitude of ground point [degrees]
    lat_deg: float
        latitude of ground point [degrees]
    z: float
        elevation of ground point above GRS80 ellipsoid [meters]
    H: float
        satellite distance to Earth center [km]
    req: float
        Earth semi-major axis of GRS80 ellipsoid (equatorial radius) [km]
    rpol: float
        Earth semi-minor axis of GRS80 ellipsoid (polar radius) [km]
    e: float
        eccentricity of ellipsoid (e=0.0818191910435 for GRS80) [unitless]
    lon_0_deg: float
        longitude of projection origin (longitude of sub-satellite point) [degrees]
    Returns
    ------------
    x: float
        ABI Fixed Grid x coordinate (scan angle) [radians]
    y: float
        ABI Fixed Grid y coordinate (elevation angle) [radians]
    &#34;&#34;&#34;
    
    # convert lat and lon from degrees to radians
    lon = np.radians(lon_deg)
    lat = np.radians(lat_deg)
    lon_0 = np.radians(lon_0_deg)
      
    # geocentric latitude
    lat_geo = np.arctan( (rpol**2 / req**2) * np.tan(lat) )

    # geocentric distance to point on the ellipsoid
    rc = rpol / np.sqrt(1 - (e**2)*(np.cos(lat_geo)**2)) # this is rc if point is on the ellipsoid
    if ~isinstance(z, int):
        rc = rc + z # this is rc if the point is offset from the ellipsoid by z (meters)

    # intermediate calculations
    Sx = H - rc * np.cos(lat_geo) * np.cos(lon - lon_0)
    Sy = -rc * np.cos(lat_geo) * np.sin(lon - lon_0)
    Sz = rc * np.sin(lat_geo)
    
    # calculate x and y scan angles
    y = np.arctan( Sz / Sx )
    x = np.arcsin( -Sy / np.sqrt( Sx**2 + Sy**2 + Sz**2 ) )
    
    ## determine if this point is visible to the satellite
    #condition = ( H * (H-Sx) ) &lt; ( Sy**2 + (req**2 / rpol**2)*Sz**2 )
    #if condition == True:
    #    print(&#39;Point at {},{} not visible to satellite.&#39;.format(lon_deg,lat_deg))
    #    return (np.nan, np.nan)
    #else:
    #    return (x,y)
    return (x,y)</code></pre>
</details>
</dd>
<dt id="goes_ortho.geometry.calcLookAngles"><code class="name flex">
<span>def <span class="ident">calcLookAngles</span></span>(<span>lon_deg, lat_deg, lon_0_deg)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate azimuth and elevation angles for a geostationary satellite viewed from Earth's surface.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lon_deg</code></strong> :&ensp;<code>float </code></dt>
<dd>longitude of ground point [degrees]</dd>
<dt><strong><code>lat_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude of ground point [degrees]</dd>
<dt><strong><code>lon_0_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of projection origin (longitude of sub-satellite point) [degrees]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>az</code></strong> :&ensp;<code>float</code></dt>
<dd>azimuth angle [degrees]</dd>
<dt><strong><code>el</code></strong> :&ensp;<code>float</code></dt>
<dd>elevation angle [degrees]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcLookAngles(lon_deg, lat_deg, lon_0_deg):
    &#34;&#34;&#34;
    Calculate azimuth and elevation angles for a geostationary satellite viewed from Earth&#39;s surface.
    
    Parameters
    ------------
    lon_deg: float 
        longitude of ground point [degrees]
    lat_deg: float
        latitude of ground point [degrees]
    lon_0_deg: float
        longitude of projection origin (longitude of sub-satellite point) [degrees]
    Returns
    ------------
    az: float
        azimuth angle [degrees]
    el: float
        elevation angle [degrees]
    &#34;&#34;&#34;
    
    
    # convert lat and lon from degrees to radians
    lon = np.radians(lon_deg)
    lat = np.radians(lat_deg)
    lon_0 = np.radians(lon_0_deg)
    
    s = lon_0 - lon
    
    el = np.arctan( ((np.cos(s)*np.cos(lon)) - 0.1512) / (np.sqrt(1 - ((np.cos(s)**2)*(np.cos(lon)**2)))) )
    
    az = np.arctan( np.tan(s)/np.sin(lon) )
    
    return(np.degrees(az) + 180, np.degrees(el))</code></pre>
</details>
</dd>
<dt id="goes_ortho.geometry.get_nested_coords"><code class="name flex">
<span>def <span class="ident">get_nested_coords</span></span>(<span>ds, x_rad, y_rad)</span>
</code></dt>
<dd>
<div class="desc"><p>Given the coordinates of a single point in the ABI Fixed Grid coordinates (x_rad and y_rad, in radians) find within a GOES ABI-L1b-Rad dataset, (any of the 2km bands) the coordinates of the nearest "2 km" (56 urad) pixel center, the coordinates of each of the pixel centers of the four "1 km" (28 urad) pixels, and the sixteen "500 m" (14 urad) pixels that are nested within the "2 km" pixel. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>xarray.Dataset</code></dt>
<dd>xarray dataset read from a GOES ABI-L1b-Rad NetCDF file of any of the "2 km" bands</dd>
<dt><strong><code>x_rad</code></strong> :&ensp;<code>float</code></dt>
<dd>x coordinate in the ABI Fixed Grid, scan angle [radians]</dd>
<dt><strong><code>y_rad</code></strong> :&ensp;<code>float</code></dt>
<dd>y coordinate in the ABI Fixed Grid, elevation angle [radians]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nearest_xs_2km</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel-centered x coordinate of 2km pixel</dd>
<dt><strong><code>nearest_ys_2km</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel-centered y coordinate of 2km pixel</dd>
<dt><strong><code>nearest_xs_1km</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel-centered x coordinates of nested 1km pixels</dd>
<dt><strong><code>nearest_ys_1km</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel-centered y coordinates of nested 1km pixels</dd>
<dt><strong><code>nearest_xs_500m</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel-centered x coordinates of nested 500 m pixels</dd>
<dt><strong><code>nearest_ys_500m</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel-centered y coordinates of nested 500 m pixels</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nested_coords(ds, x_rad, y_rad):
    
    &#34;&#34;&#34;
    Given the coordinates of a single point in the ABI Fixed Grid coordinates (x_rad and y_rad, in radians) find within a GOES ABI-L1b-Rad dataset, (any of the 2km bands) the coordinates of the nearest &#34;2 km&#34; (56 urad) pixel center, the coordinates of each of the pixel centers of the four &#34;1 km&#34; (28 urad) pixels, and the sixteen &#34;500 m&#34; (14 urad) pixels that are nested within the &#34;2 km&#34; pixel. 
    
    Parameters
    ------------
    ds: xarray.Dataset
        xarray dataset read from a GOES ABI-L1b-Rad NetCDF file of any of the &#34;2 km&#34; bands
    x_rad: float
        x coordinate in the ABI Fixed Grid, scan angle [radians]
    y_rad: float
        y coordinate in the ABI Fixed Grid, elevation angle [radians]
    Returns
    ------------
    nearest_xs_2km: float
        pixel-centered x coordinate of 2km pixel
    nearest_ys_2km: float
        pixel-centered y coordinate of 2km pixel
    nearest_xs_1km: float
        pixel-centered x coordinates of nested 1km pixels
    nearest_ys_1km: float
        pixel-centered y coordinates of nested 1km pixels
    nearest_xs_500m: float
        pixel-centered x coordinates of nested 500 m pixels
    nearest_ys_500m: float
        pixel-centered y coordinates of nested 500 m pixels
    &#34;&#34;&#34;
    
    # &#34;2 km&#34; pixel coordinate
    nearest_xs = ds.sel(x=x_rad, y=y_rad, method=&#34;nearest&#34;).x
    nearest_ys = ds.sel(x=x_rad, y=y_rad, method=&#34;nearest&#34;).y
    nearest_xs_2km, nearest_ys_2km = np.meshgrid(nearest_xs, nearest_ys)
    
    # &#34;1 km&#34; pixel coordinates
    nearest_xs_1km, nearest_ys_1km = np.meshgrid(np.linspace(nearest_xs_2km[0][0]-(28e-6)*0.5, nearest_xs_2km[0][0]+(28e-6)*0.5, num=2), \
                                                 np.linspace(nearest_ys_2km[0][0]-(28e-6)*0.5, nearest_ys_2km[0][0]+(28e-6)*0.5, num=2))

    # &#34;500 m&#34; pixel coordinates
    nearest_xs_500m, nearest_ys_500m = np.meshgrid(np.linspace(nearest_xs_2km[0][0]-(14e-6)*1.5, nearest_xs_2km[0][0]+(14e-6)*1.5, num=4), \
                                                   np.linspace(nearest_ys_2km[0][0]-(14e-6)*1.5, nearest_ys_2km[0][0]+(14e-6)*1.5, num=4))


    return nearest_xs_2km, nearest_ys_2km, nearest_xs_1km, nearest_ys_1km, nearest_xs_500m, nearest_ys_500m</code></pre>
</details>
</dd>
<dt id="goes_ortho.geometry.goes_azi"><code class="name flex">
<span>def <span class="ident">goes_azi</span></span>(<span>lat_ssp, lon_ssp, lat, lon)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute azimuth for geostationary satellite, not GOES specific, spherical Earth assumption
See also: <a href="http://tiij.org/issues/issues/3_2/3_2e.html">http://tiij.org/issues/issues/3_2/3_2e.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lat_ssp</code></strong> :&ensp;<code>float</code></dt>
<dd>sub-satellite point latitude [degrees]</dd>
<dt><strong><code>lon_ssp</code></strong> :&ensp;<code>float</code></dt>
<dd>sub-satellite point longitude [degrees]</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>view point latitude on Earth's surfaace [degrees]</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>view point longitude on Earth's surface [degrees]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>azi</code></strong> :&ensp;<code>float</code></dt>
<dd>azimuth angle [degrees]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goes_azi(lat_ssp, lon_ssp, lat, lon):
    
    &#34;&#34;&#34;
    Compute azimuth for geostationary satellite, not GOES specific, spherical Earth assumption
    See also: http://tiij.org/issues/issues/3_2/3_2e.html
    
    Parameters
    ------------
    lat_ssp: float
        sub-satellite point latitude [degrees]
    lon_ssp: float
        sub-satellite point longitude [degrees]
    lat: float
        view point latitude on Earth&#39;s surfaace [degrees]
    lon: float
        view point longitude on Earth&#39;s surface [degrees]
    Returns
    ------------
    azi: float
        azimuth angle [degrees]
    &#34;&#34;&#34;
    
    azi = 180 + np.degrees( np.arctan(np.tan(np.radians(lon_ssp - lon))/np.sin(np.radians(lat))) )
    
    return azi.T</code></pre>
</details>
</dd>
<dt id="goes_ortho.geometry.goes_lza"><code class="name flex">
<span>def <span class="ident">goes_lza</span></span>(<span>lat_ssp, lon_ssp, lat, lon, H=42164.16, r_eq=6378.137)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Locan Zenith Angle for a point on Earth surface to a GOES-R geostationary satellite.
See more details from NOAA here: <a href="https://www.ncdc.noaa.gov/sites/default/files/attachments/GOES-R_ABI_local_zenith_angle_description.docx">https://www.ncdc.noaa.gov/sites/default/files/attachments/GOES-R_ABI_local_zenith_angle_description.docx</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lat_ssp</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>sub-satellite point latitude [degrees]</dt>
<dt><strong><code>lon_ssp</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>sub-satellite point longitude [degrees]</dt>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>view point latitude on Earth's surfaace [degrees]</dt>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>view point longitude on Earth's surface [degrees]</dt>
<dt><strong><code>elev</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>view point elevation (heigh above GRS80 ellispoid) [km]</dt>
<dt><strong><code>H</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>satellite distance to Earth center [km] (defaults to 42164.16 km)</dt>
<dt><strong><code>r_eq</code></strong> :&ensp;<code>float</code></dt>
<dd>Earth semi-major axis (GRS80 ellipsoid) [km] (defaults to 6378.137 km)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LZA: float
local zenith angle [degrees]
is_point_visible: bool
True/False flag indicating if the ground point is actually visible to the satellite</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goes_lza(lat_ssp, lon_ssp, lat, lon, H=42164.16, r_eq=6378.137):
    
    &#34;&#34;&#34;
    Compute the Locan Zenith Angle for a point on Earth surface to a GOES-R geostationary satellite.
    See more details from NOAA here: https://www.ncdc.noaa.gov/sites/default/files/attachments/GOES-R_ABI_local_zenith_angle_description.docx
    
    Parameters
    ------------
    lat_ssp: float
       sub-satellite point latitude [degrees]
    lon_ssp: float
       sub-satellite point longitude [degrees]
    lat: float
       view point latitude on Earth&#39;s surfaace [degrees]
    lon: float
       view point longitude on Earth&#39;s surface [degrees]
    elev: float
       view point elevation (heigh above GRS80 ellispoid) [km]
    H: float
       satellite distance to Earth center [km] (defaults to 42164.16 km)
    r_eq: float
        Earth semi-major axis (GRS80 ellipsoid) [km] (defaults to 6378.137 km)
    Returns
    ------------ 
    LZA: float
        local zenith angle [degrees]
    is_point_visible: bool
        True/False flag indicating if the ground point is actually visible to the satellite
    &#34;&#34;&#34;

    # intermediate calculation
    B = np.arccos( np.cos(np.radians(lat)-np.radians(lat_ssp)) * np.cos(np.radians(lon)-np.radians(lon_ssp)) )

    # determine if point is visible to the satellite
    is_point_visible = (B &lt; np.arccos(r_eq / (H+r_eq)))

    # compute LZA
    LZA_radians = np.arcsin( (H * np.sin(B) ) / ( np.sqrt( H**2 + r_eq**2 - 2*H*r_eq*np.cos(B) ) ) )
    
    # convert LZA from radians to degrees
    LZA = LZA_radians * 180/np.pi
    
    return LZA, is_point_visible</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="goes_ortho" href="index.html">goes_ortho</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="goes_ortho.geometry.ABIangle2LonLat" href="#goes_ortho.geometry.ABIangle2LonLat">ABIangle2LonLat</a></code></li>
<li><code><a title="goes_ortho.geometry.LonLat2ABIangle" href="#goes_ortho.geometry.LonLat2ABIangle">LonLat2ABIangle</a></code></li>
<li><code><a title="goes_ortho.geometry.calcLookAngles" href="#goes_ortho.geometry.calcLookAngles">calcLookAngles</a></code></li>
<li><code><a title="goes_ortho.geometry.get_nested_coords" href="#goes_ortho.geometry.get_nested_coords">get_nested_coords</a></code></li>
<li><code><a title="goes_ortho.geometry.goes_azi" href="#goes_ortho.geometry.goes_azi">goes_azi</a></code></li>
<li><code><a title="goes_ortho.geometry.goes_lza" href="#goes_ortho.geometry.goes_lza">goes_lza</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>